// need to keep track of smallest received ack

int curr_seq_num //sequence number of first index of our window
packet *window[window_size] //window, initialize indices to -1
packet *rcv_buf//receive buffer
char *nack_array
packet *cum_ack

for(;;) {
    for(window_size/2) {
        select
        if (not timeout) {
            recv(&packet);
            //in other words, *disregard* when packet.index is out of range
            if (curr_seq_num < packet.index)
                window[packet.index % window_size] = packet;
                nack_array[packet.index % window_size] = 1;
                shift_window();
    }
    cum_ack.index = curr_seq_num;
    cum_ack.payload = nack_array;
    send(ack);
    }
}

shift_window {
    while(window[curr_seq_num].index > -1) {
        write window[curr_seq_num];
        window[curr_seq_num].index = -1;
        nack_array[curr_seq_num] = 0;
        curr_seq_num++;
    }
}

cumulative_ack {
    sequence number of last non-null packet in a row //updates window
    array of bools
}
