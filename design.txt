Distributed Systems Assignment 1 Design Doc

Daniel Swann
John An

****** Packet Structure ******

We will transfer the file using custom packets with a total size of 1400 bytes. Our packet will contain a uniquely incrementing sequence number integer, an acknowledgement number integer as part of our cumulative ack process, a data payload of size 1388 bytes (1400 bytes - the header), and an integer FIN field that is initially set to -1 (otherwise it is the of the last character in the file, sent in the last packet).

packet.h struct contains:
int index (sequence number) - will never overflow with a 500 MB file
int ack_num (acknowledgement number)
char payload[PAYLOAD_SIZE] - payload size is 1388 bytes
int FIN (to determine if the packet is the last in sequence)

****** Selective Repeat Algorithm ******

We will use a modified version of the selective repeat protocol for our windowed packet transfer process. Both the sender and receiver contain a circular window array to hold current packets and a corresponding array of acks/nacks. A cumulative ack is sent every half window, and contains the sequence number of the most recently received in-order packet (aka the packet just before the first nack), as well as a payload of an array of acks and nacks corresponding to the current window. After much trial and error, we found that 512 packets was an efficient window size, and 5 ms was a great timeout rate.

-- Sending packets: ncp.c --

ncp.c contains some key global variables in order to keep track of things.  

    int loss_rate - passed to send_dbg, taken as argument 1 from the shell
    int new_sn - the sequence number representing the index of a newly shifted window, used to updated lack_acked_sn
    int last_acked_sn - the index of the packet to most recently be acked, aka the "start of the current window"
    int last_sent_sn - the index of the most recently sent packet, aka the "end of the current window"
    struct packet window[WINDOW_SIZE] - an array of packet structs representing the current window
    char ack_array[WINDOW_SIZE] - an array of booleans representing the packet acks currently received

Stats globals, used for calculating transfer statistics:
    int total_data_transferred - number of bytes sent thus far
    struct timeval start_time - beginning execution time of the program
    struct timeval local_time - used for calculating 50 MB interval stats

Two secondary functions are included for argument parsing (split_string) and statistics calculation (print_stats)

Sending algorithm:

    1. Initialize global variables and start global timer
           Split the third argument into filename and hostname at the '@' symbol
    2. Perform socket opening logic with given hostname
    3. Make sure we can open the given file for reading
    4. Initialize the first packet with a sequence number of -1 and a payload of the filename to write to on the receiver side
    5. Continuously send this first packet indefinitely until an ack is received from the sender with an ack number of -1 or a timeout occurs This is to ensure that the host is responsive and will know the proper filename to write to
    6. After this first ack is received, we then initialze all the packets in the window array with a sequence number of -1, a FIN of -1, and ack_num of -1. The corresponding boolean in the ack_array is also updated with a value of 0.
    7. Begin the file transfer by looping indefinitely
        If the is_done variable (used for breaking out of multiple loops) is set, break
        If the first packet in the window has a sequence number of zero (meaning we're at the first window), we send batch send this window to the receiver and update the last_sent_sn value to the last sequence number in this window
        Check if we have received an ack packet from the sender
             If so, we first make sure the ack packet received has a sequence number greater than the last_acked_sn (otherwise it's already been acked and we do nothing)
             We then calculate the new sequence number offset by subtracting the current lask_ack_sn from the received sequence number.
             The window is shifted by this new_sn offset by updating the window's packets in a while loop (while last_acked_sn < new_sn)
                 We read in PAYLOAD_SIZE new chars from the file and put them in the necessary packets
                 Update the ack_array at this index to false, indicating a new packet to sent
                 If the number of chars read is less than the max PAYLOAD_SIZE, we need to send the last packet so we break the loop
                 Otherwise it's not a last packet, set its FIN value to -1
             Resend all packets in the window according the booleans in the received cumulative ack, update the window indexes accordingly             

        Otherwise we've encountered a timeout, so resend all the packets who have false (0) values in the current ack_array.

    8. Close the file and stop timer, we've sent everything succesfully


-- Receiving packets: rcv.c --

Globals:

    int loss_rate - passed to send_dbg, taken as argument 1 from the shell
    int curr_seq_num - the index of the last
    char * filename - the 
    struct packet first_packet - 
    struct packet rcv_buf - the temp packet received each time from the sender
    struct packet window[WINDOW_SIZE] - holds current window of packets before writing to file
    char nack_array[WINDOW_SIZE] - the window's corresponding boolean array of acks and nacks to send 


    Stats globals, used for calculating transfer statistics:
        int total_data_transferred - number of bytes sent thus far
        struct timeval start_time - beginning execution time of the program
        struct timeval local_time - used for calculating 50 MB interval stats





Additional Information:

In order to transmit the last packet of the file which may contain an arbitrary number of bytes padded by zeros, the FIN field will contain zero until the npc function pointer encounters the EOF character. After which, the FIN field of the last packet will be set to the index of the EOF character in the last data payload. This is to ensure that the remainder of the file is written to disk correctly, with no extraneous padding.

We donâ€™t need to worry about the upper bound for the loop in rcv function, when it encounters the FIN packet, it disregards any information left in the window and writes everything in the packet to the file.
